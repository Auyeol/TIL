### 오늘 TIL 요약 
-------
`카운팅 정렬` 
-------

### 카운팅 정렬 
- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여 정렬하는 알고리즘
- 카운트를 하기 위한 충분한 공간을 할당하기 위해서 집합 내의 가장 큰 정수(k)를 알아야 한다. 
- 비교환 방식으로 이루어지므로 k(max값)가 비교적 작을 때만 사용한다.
  - if) k가 10000이라면 10000개의 원소를 전부 다 세어야 하기 때문에<br/> 메모리 낭비와 시간 소모가 크다

- **시간 복잡도 -> O(n+k)**<br/>n은 리스트 길이, k는 정수의 최댓값 

[제한 사항]
- 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
  - 각 항목의 발생 횟수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문

-------
### TIL(Today I learned) 날짜

2024.01.30

-------

# 사진 넣기 
# 사진 넣기 
# 사진 넣기 
# 사진 넣기 
# 사진 넣기 
# 사진 넣기 
[!버블 정렬] (./TIL_image/BubbleSort.jpg)

### 1단계
- DATA에서 각 항목들의 발생 횟수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 COUNTS에 저장한다. 
  
    ```python
    for i in DATA:
        COUNTS[i] += 1
    ```

- 정렬된 집합에서 각 항목의 앞의 위치할 항목의 개수를 반영하기 위해 counts의 원소를 조정한다. (누적합)

    ```python
    for i in range(1, K+1):
    COUNTS[i] += COUNTS[i-1]
    ```

### 2단계

- 원본데이터와 동일한 TEMP를 만든다.
- DATA의 마지막 인덱스부터 시작하여 0까지 실행한다.<br/><span style="color:gray">0까지 이므로 for문의 2번째 인자는 -1</span><br/>
  `for i in range(N-1, -1, -1):`
- DATA의 마지막 인덱스의 값과 동일한 COUNTS의 인덱스로 이동하여 해당 인덱스의 값을 -1 한 뒤, 감소된 값을 TEMP의 인덱스로 사용한다. 이후, TEMP 인덱스에 DATA의 마지막 인덱스 값을 집어넣는다. 
- 위의 과정을 DATA의 인덱스가 0이 될 때 까지 DATA의 인덱스를 1씩 감소하면서 반복한다.

```python
DATA = [0, 4, 1, 3, 1, 2, 4, 1]
K = 4 # max(DATA)
COUNTS = [0] * (K+1) # 0부터 존재하므로 K+1개의 원소를 생성
TEMP = [-1] * len(DATA) # 0으로 해두면 값이 들어가서 0인지 아닌지 모르기 때문에 -1로 초기화

# 각 숫자들의 개수 세기
for i in DATA:
    COUNTS[i] += 1
        # COUNTS = [1, 3, 1, 1, 2]

# 원소들의 누적합 구하기
for i in range(1, K+1):
    COUNTS[i] += COUNTS[i-1]
        # COUNTS = [1, 4, 5, 6, 8]


# 카운팅 정렬
for i in range(len(DATA)-1, -1, -1):
    COUNTS[DATA[i]] -= 1
    TEMP[COUNTS[DATA[i]]] = DATA[i]


print(TEMP)        
```
---------
### 개인적인 생각

<br/>0의 개수 1개, 1의 개수 3개, 2의 개수 1개 , 3의 개수 1개, 4의 개수 2개
<br/><br/>따라서, 1이 들어간다고 하면 1은 2,3,4번째에 들어갈 수 있음
<br/><br/>안정정렬을 하기 위해서는 뒤에서 부터 넣어야함
<br/><br/>저기서 COUNTS는 4를 나타내고 있는데, 이는 이전의 값들을 다 더했기 때문에
<br/><br/>2번째 인덱스 COUTNS[2]를 예시로 들면, 1+3 = 4
<br/><br/>0과 1이 들어간 범위는 4칸임을 나타내는 것
<br/><br/>따라서 4번째 인덱스까지 1이 들어갈 수 있음, DATA[4]는 5번째 인덱스 -> 2가 들어갈 자리 -> -1을 하면 1이 들어갈 수 있는 마지막 자리를 알아낼 수 있다.

--------

> <span style="color:orange">**뒤에서 부터 정렬을 시작하는 이유?**</span><br/>
> **if)** 1의 값이 여러 개 존재한다고 했을 때, 앞에서부터 정렬을 시작하는 경우 안정정렬이 불가능하다.<br/>
> &nbsp;&nbsp;&nbsp;정렬할 때마다 COUNTS의 값이 1씩 내려가므로 앞에서부터 정렬을 시작하는 경우, 앞에 있는 1이 뒤에 있는 1보다 뒤에 가게 된다. 
><br/>
> ex) [1(1), 1(2), 1(3), 2, 5, 4, 3]   <span style="color:gray">숫자 1 뒤의 (1)은 첫번째 1, (2)는 두번째 1을 의미한다</span><br/>
>   &nbsp;&nbsp;&nbsp;앞에서부터 시작하는 경우<br/>&nbsp;&nbsp;&nbsp; [1(3), 1(2), 1(1), 2, 3, 4, 5]로 가장 뒤에있는 1이 가장 앞으로 오게 됨 
