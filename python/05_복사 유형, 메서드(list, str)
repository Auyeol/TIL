### 오늘 TIL 요약 
-------
`복사 유형` `시퀀스 데이터 구조인 list, str의 메서드` 
-------
**1. 파이썬에서는 데이터의 분류에 따라 복사가 달라진다<br/>&nbsp;`변경 가능한 데이터 타입`/`변경 불가능한 데이터 타입`**  
 
**2. 파이썬의 복사 유형에는 1. 할당, 2. 얕은 복사, 3. 깊은 복사가 있다.**

**3. `append()`로 리스트를 추가 시, 리스트 자체로 추가가 되고<br/>&nbsp;`extend()`로 리스트를 추가하면 원소로 추가된다.

-------
### TIL(Today I learned) 날짜
2024.01.22
-------
## 세부내용

### 데이터 타입과 복사 

```python
a = [1,2,3,4]
b = a
b[0] = 100 
print(a) # [100, 2, 3, 4] # 리스트 b의 값만 바꿨는데 a의 값도 바뀌게 됨
print(b) 
```
![Untitled](./TIL_image/데이터%20타입과%20복사.png)
리스트 b에 새로운 주소를 할당하는 것이 아니라, 같은 주소를 참조하고있다.
따라서 리스트 a도 동일하게 값이 변경된다. 


```python
# 변경이 불가능한 값을 저장하므로 값이 변경되지 않음
# 리스트는 참조 주소(?)가 저장되므로 변경됨 
a = 100 # 
b = a
b = 9
print(a) # 100
print(b) # 9
```

## 복사유형

  ### 1. 할당
  - 할당 연산자 `=`를 통한 복사는 해당 객체에 대한 객체 참조를 복사
  ```python
  original_list = [1,2,3]
  copy_list = original_list
  copy_list[0] = 'hello'
  print(original_list) # ['hello',2,3]
  ```

  ### 2. 얕은 복사
  - 슬라이싱은 슬라이싱한 결과를 <span style="color:red"> 새로운 리스트</span>로 반환하기에 슬라이싱을 통해 생성된 객체는 원본 객체와 독립적으로 존재하게 된다. 
  ```python
  a = [1,2,3]
  b = a[:]
  print(a, b) # [1,2,3] [1,2,3]
  b[0] = 100
  print(a, b) # [1,2,3] [100,2,3] # a의 값은 바뀌지 않고 b의 값만 변경된다..
  ```

  **얕은 복사의 문제점**</br>
  -> 2차원 리스트와 같이 변경 가능한 객체 안에 변경 가능한 객체가 있는 경우 한계가 있다.
  </br>
  -> a와 b의 주소는 다르지만, 내부 객체의 주소는 같기 때문에 함께 변경되기 때문이다. 
  <br/>
  ![얕은복사](./TIL_image/얕은%20복사.png)
  
  ```python
  a = [1,2, [1,2]]
  b = a[:]
  print(a, b) # [1,2,[1,2]] [1,2,[1,2]]

  b[2][0] = 100
  # 리스트 안에 리스트가 존재 / 변경 가능한 객체 안에 변경 가능한 객체가 존재
  print(a,b) # [1,2,[100,2]] [1,2,[100,2]]
  ```
  
  
  ### 3. 깊은 복사
  - 파이썬의 내장 모듈인 copy 모듈을 이용, `copy.deepcopy()`를 이용하여 해당 값을 복사한다. 
  - 해당 모듈을 이용하면 내부에 중첩된 모든 객체까지 새로운 객체 주소로 참조하게 해준다. 

  ```python
  import copy

  original_list = [1,2,[1,2]]
  deep_coopied_list = copy.deepcopy(original_list)
  deep_copied_list[2][0] = 100

  print(original_list) # [1,2, [1,2]] # original의 값은 변경되지 않게됨
  print(deep_copied_list) # [1,2, [100,2]]
  ```

  ![깊은복사](./TIL_image/깊은%20복사.png)

---------

## 시퀀스 데이터 구조

### 문자열 조회/탐색 및 검증 메서드

|메서드|설명|
|---|---|
|s.find(x)|x의 첫 번째 위치를 반환, 없으면 -1을 반환|
|s.index(x)|x의 첫 번째 위치를 반환, 없으면 '오류' 발생|
|s.isalpha()|알파벳 문자 여부, 유니코드 상의 Letter인지 판단|
|s.isupper()|문자열이 모두 대문자로 이루어져 있는지 확인|
|s.islower()|문자열이 모두 소문자로 이루어져 있는지 확인|
|s.istitle()|타이틀 형식 여부를 확인|
--------
### 문자열 조작 메서드(새 문자열 반환)

|메서드|설명|
|---|---|
|s.replace(old,new[,count])|바꿀 대상 글자를 새로운 글자로 바꿔서 반환|
|s.strip([chars])|공백이나 특정 문자를 제거|
|s.split(set=None, maxsplit=-1)|공백이나 특정 문자를 기준으로 분리|
|'separator'.join([iterable])|구분자로 iterable을 합침|
|s.capitalize()|가장 첫 번째 글자를 대문자로 변경|
|s.title()|문자열 내 띄어쓰기 기준으로 각 단어의 첫 글자는 대문자로, 나머지는 소문자로 변환|
|s.upper()|모두 대문자로 변경|
|s.lower()|모두 소문자로 변경|
|s.swapcase()|대↔소문자 서로 변경|
-------
### 리스트 값 추가 및 삭제 메서드

|메서드|설명|
|---|---|
|l.append(x)|리스트 마지막에 항목 x를 추가|
|l.extend(m)|Iterable m의 모든 항목들을 리스트 끝에 추가|
|l.insert(i,x)|리스트 인덱스 i에 항목 x를 삽입|
|l.remove(x)|리스트 항목의 첫번재 x를 제거, 항목 존재하지 않을 경우 ValueError발생|
|l.pop()|리스트 가장 오른쪽에 있는 항목을 <span style="color:red">반환</span> 후 제거|
|l.clear()|리스트의 모든 항목을 삭제|

### 리스트 탐색 및 정렬 메서드

|메서드|설명|
|---|---|
|l.index(x, start, end)|리스트에 있는 항목 중 가장 왼쪽에 있는 항목 x의 인덱스를 반환|
|l.reverse()|리스트의 순서를 <span style="color:red">역순</span>으로 변경, *(정렬 X)*
|l.sort()|리스트를 정렬, reverse=False가 default|
|l.count(x)|리스트에서 항목 x의 개수를 반환|